SET-1
1. Use the date and who commands in sequence (in one line) such that the output of date will display on the screen and the output of who will be redirected to a file called myfile2. Use the more command to check the contents of myfile2.

	date ; who>myfile2.txt
	more myfile2.txt

2. Wap to demonstrate orphan and zombie processes.

//orphan program
#include<unistd.h>
#include<stdio.h>
int main()
{
        pid_t i = fork();
        if(i==0)
        {
                printf("sleeping");
                printf("id of parent from child is %d",getppid());
                sleep(5);
        }
        else
        {
                printf("parent");
        }
        return 0;
}

//zombie program
#include<unistd.h>
#include<stdio.h>
int main()
{
        pid_t i = fork();
        if(i>0)
        {
                printf("id of parent is %d",i);
                sleep(8);
                printf("sleeping");
        }
        else
        {
                printf("id of parent from child is %d",getppid());
                printf("id of child from child is %d",getpid());
                _exit(0);
        }
        return 0;
}

SET-2
1. Wap using fork() and execvp() [to execute user defined program]

#include<stdio.h>
#include<unistd.h>
int main()
{
        printf("This the parent process");
        pid_t x=fork();
        if(x==0)
        {
                printf("I am child process and my id is %d\n",getpid());
                char *argv[]={"hiiiiiii","hello",NULL};
                execvp("./example",argv);
                printf("\nI won't be printed\n");
        }

        printf("\nI am end of the process");
        return 0;
}
 
#include<stdio.h>
int main(int no,char *argv[])
{
	printf("i am abccc\n");
	printf(" %s ",argv[1]);
	return 0;
}


2. write a C program to execute zombie and orphan process in a single program

#include <stdio.h> 
int main() 
{ 
  
    int x; 
    x = fork(); 
  
    if (x > 0) 
        printf("IN PARENT PROCESS\nMY PROCESS ID  
                              : %d\n", getpid()); 
  
    else if (x == 0) { 
        sleep(5); 
        x = fork(); 
  
        if (x > 0) { 
   printf("IN CHILD PROCESS\nMY PROCESS ID :%d\n 
           PARENT PROCESS ID : %d\n", getpid(), getppid()); 
  
   while(1) 
     sleep(1); 
  
   printf("IN CHILD PROCESS\nMY PARENT PROCESS ID  
                               : %d\n", getppid()); 
        } 
  
        else if (x == 0) 
            printf("IN CHILD'S CHILD PROCESS\n 
                  MY PARENT ID : %d\n", getppid()); 
    } 
  
    return 0; 
} 

SET-3
1. Create a hierarchy (using fork () system call) of client processes(3 processes) and a single server process(parent processes)

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
int main() 
{ 
    int pid, pid1, pid2; 
    pid = fork(); 
    if (pid == 0) { 
        sleep(3); 
        printf("child[1] --> pid = %d and ppid = %d\n", 
               getpid(), getppid()); 
    } 
  
    else { 
        pid1 = fork(); 
        if (pid1 == 0) { 
            sleep(2); 
            printf("child[2] --> pid = %d and ppid = %d\n", 
                   getpid(), getppid()); 
        } 
        else { 
            pid2 = fork(); 
            if (pid2 == 0) { 
                printf("child[3] --> pid = %d and ppid = %d\n", 
                       getpid(), getppid()); 
            } 
            else { 
                sleep(3); 
                printf("parent --> pid = %d\n", getpid()); 
            } 
        } 
    } 
  
    return 0; 
} 

2. Write a program that takes a command –line argument and reports complete status of a file and display whether it is directory, a file, or something else.


SET-4
1. Use the ps, ps lx, ps tree and ps -aux command to display the process attributes.


2. Wap using fork() and execvp() [to execute pre defined program ex:ls ]

#include<stdio.h>
#include<unistd.h>
int main()
{
	printf("This the parent process");
	pid_t x=fork();
	if(x==0)
	{
		printf("I am child process and my id is %d\n",getpid());
		char *argv[]={"ls",NULL};
		execvp("ls",argv);
		printf("\nI won't be printed\n");
	}

	printf("\nI am end of the process");
	return 0;
}

SET-5
1. Use system call to get the attributes of a file.


2. Program to create four processes (1 parent and 3 children) where they terminate in a sequence as follows:
(a) Parent process terminates at last
(b) First child terminates before parent and after second child.
(c) Second child terminates after last and before first child.
(d) Third child terminates first.

	refer set-3 1question

SET-6
1. Create a hierarchy (using fork() system call) of client processes as shown in the figure and a single server process.


2. Write a C program in which the child process takes an input array and send it to the parent process using pipe() and fork() and then print it in the parent process.

#include <stdio.h>  
#include <unistd.h> 
#include <sys/wait.h> 
#define MAX 10 

int main() 
{ 

int fd[2], i = 0; 
pipe(fd); 
pid_t pid = fork(); 

if(pid > 0) { 
	wait(NULL); 

	// closing the standard input 
	close(0); 

	// no need to use the write end of pipe here so close it 
	close(fd[1]); 

	// duplicating fd[0] with standard input 0 
	dup(fd[0]); 
	int arr[MAX]; 

	// n stores the total bytes read succesfully 
	int n = read(fd[0], arr, sizeof(arr)); 
	for ( i = 0;i < n/4; i++) 

		// printing the array received from child process 
		printf("%d ", arr[i]); 
} 
else if( pid == 0 ) { 
	int arr[] = {1, 2, 3, 4, 5}; 

	// no need to use the read end of pipe here so close it 
	close(fd[0]); 

	// closing the standard output 
	close(1);	 

	// duplicating fd[0] with standard output 1 
	dup(fd[1]); 
	write(1, arr, sizeof(arr)); 
} 
